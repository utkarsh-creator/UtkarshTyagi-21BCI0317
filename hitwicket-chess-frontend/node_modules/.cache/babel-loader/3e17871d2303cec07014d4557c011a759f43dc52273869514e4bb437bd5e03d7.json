{"ast":null,"code":"function CombatLogic(gameState, move) {\n  const {\n    selectedCharacter,\n    moveDirection\n  } = move;\n  const {\n    board,\n    currentPlayer\n  } = gameState;\n  const updatedBoard = board.map(row => row.slice());\n  const updatedMoveHistory = [...gameState.moveHistory, `${selectedCharacter}: ${moveDirection}`];\n\n  // Find the current position of the selected character\n  let currentPos = null;\n  for (let row = 0; row < 5; row++) {\n    for (let col = 0; col < 5; col++) {\n      if (updatedBoard[row][col] === selectedCharacter) {\n        currentPos = {\n          row,\n          col\n        };\n        break;\n      }\n    }\n    if (currentPos) break;\n  }\n  if (!currentPos) {\n    console.error(\"Character not found on the board.\");\n    return {\n      ...gameState\n    };\n  }\n  const {\n    row,\n    col\n  } = currentPos;\n  let newRow = row,\n    newCol = col;\n\n  // Determine new position based on moveDirection\n  switch (moveDirection) {\n    case 'UP':\n      newRow = row - 1;\n      break;\n    case 'DOWN':\n      newRow = row + 1;\n      break;\n    case 'LEFT':\n      newCol = col - 1;\n      break;\n    case 'RIGHT':\n      newCol = col + 1;\n      break;\n    default:\n      console.error(\"Invalid move direction.\");\n      return {\n        ...gameState\n      };\n  }\n\n  // Validate new position\n  if (newRow < 0 || newRow >= 5 || newCol < 0 || newCol >= 5) {\n    console.error(\"Move out of bounds.\");\n    return {\n      ...gameState\n    };\n  }\n\n  // Handle combat logic\n  const opponentPrefix = currentPlayer === 'A' ? 'B-' : 'A-';\n  const isHero = selectedCharacter.endsWith('H1') || selectedCharacter.endsWith('H2');\n  if (isHero) {\n    // Remove all opponent characters in the path for Hero1 and Hero2\n    if (moveDirection === 'UP' || moveDirection === 'DOWN') {\n      for (let i = Math.min(row, newRow); i <= Math.max(row, newRow); i++) {\n        if (updatedBoard[i][col] && updatedBoard[i][col].startsWith(opponentPrefix)) {\n          updatedBoard[i][col] = null;\n        }\n      }\n    } else if (moveDirection === 'LEFT' || moveDirection === 'RIGHT') {\n      for (let i = Math.min(col, newCol); i <= Math.max(col, newCol); i++) {\n        if (updatedBoard[row][i] && updatedBoard[row][i].startsWith(opponentPrefix)) {\n          updatedBoard[row][i] = null;\n        }\n      }\n    }\n  } else {\n    // Regular characters remove only the opponent at the final position\n    if (updatedBoard[newRow][newCol] && updatedBoard[newRow][newCol].startsWith(opponentPrefix)) {\n      updatedBoard[newRow][newCol] = null;\n    }\n  }\n\n  // Move the selected character to the new position\n  updatedBoard[row][col] = null;\n  updatedBoard[newRow][newCol] = selectedCharacter;\n\n  // Check if the game is over\n  const gameOver = !updatedBoard.flat().some(cell => cell && cell.startsWith(opponentPrefix));\n  const winner = gameOver ? currentPlayer : null;\n  return {\n    updatedBoard,\n    updatedMoveHistory,\n    gameOver,\n    winner\n  };\n}\n_c = CombatLogic;\nexport default CombatLogic;\nvar _c;\n$RefreshReg$(_c, \"CombatLogic\");","map":{"version":3,"names":["CombatLogic","gameState","move","selectedCharacter","moveDirection","board","currentPlayer","updatedBoard","map","row","slice","updatedMoveHistory","moveHistory","currentPos","col","console","error","newRow","newCol","opponentPrefix","isHero","endsWith","i","Math","min","max","startsWith","gameOver","flat","some","cell","winner","_c","$RefreshReg$"],"sources":["C:/Users/Trisha/hitwicket/hitwicket-chess-frontend/src/components/CombatLogic.js"],"sourcesContent":["function CombatLogic(gameState, move) {\n    const { selectedCharacter, moveDirection } = move;\n    const { board, currentPlayer } = gameState;\n\n    const updatedBoard = board.map(row => row.slice());\n    const updatedMoveHistory = [...gameState.moveHistory, `${selectedCharacter}: ${moveDirection}`];\n\n    // Find the current position of the selected character\n    let currentPos = null;\n    for (let row = 0; row < 5; row++) {\n        for (let col = 0; col < 5; col++) {\n            if (updatedBoard[row][col] === selectedCharacter) {\n                currentPos = { row, col };\n                break;\n            }\n        }\n        if (currentPos) break;\n    }\n\n    if (!currentPos) {\n        console.error(\"Character not found on the board.\");\n        return { ...gameState };\n    }\n\n    const { row, col } = currentPos;\n    let newRow = row, newCol = col;\n\n    // Determine new position based on moveDirection\n    switch (moveDirection) {\n        case 'UP':\n            newRow = row - 1;\n            break;\n        case 'DOWN':\n            newRow = row + 1;\n            break;\n        case 'LEFT':\n            newCol = col - 1;\n            break;\n        case 'RIGHT':\n            newCol = col + 1;\n            break;\n        default:\n            console.error(\"Invalid move direction.\");\n            return { ...gameState };\n    }\n\n    // Validate new position\n    if (newRow < 0 || newRow >= 5 || newCol < 0 || newCol >= 5) {\n        console.error(\"Move out of bounds.\");\n        return { ...gameState };\n    }\n\n    // Handle combat logic\n    const opponentPrefix = currentPlayer === 'A' ? 'B-' : 'A-';\n    const isHero = selectedCharacter.endsWith('H1') || selectedCharacter.endsWith('H2');\n\n    if (isHero) {\n        // Remove all opponent characters in the path for Hero1 and Hero2\n        if (moveDirection === 'UP' || moveDirection === 'DOWN') {\n            for (let i = Math.min(row, newRow); i <= Math.max(row, newRow); i++) {\n                if (updatedBoard[i][col] && updatedBoard[i][col].startsWith(opponentPrefix)) {\n                    updatedBoard[i][col] = null;\n                }\n            }\n        } else if (moveDirection === 'LEFT' || moveDirection === 'RIGHT') {\n            for (let i = Math.min(col, newCol); i <= Math.max(col, newCol); i++) {\n                if (updatedBoard[row][i] && updatedBoard[row][i].startsWith(opponentPrefix)) {\n                    updatedBoard[row][i] = null;\n                }\n            }\n        }\n    } else {\n        // Regular characters remove only the opponent at the final position\n        if (updatedBoard[newRow][newCol] && updatedBoard[newRow][newCol].startsWith(opponentPrefix)) {\n            updatedBoard[newRow][newCol] = null;\n        }\n    }\n\n    // Move the selected character to the new position\n    updatedBoard[row][col] = null;\n    updatedBoard[newRow][newCol] = selectedCharacter;\n\n    // Check if the game is over\n    const gameOver = !updatedBoard.flat().some(cell => cell && cell.startsWith(opponentPrefix));\n    const winner = gameOver ? currentPlayer : null;\n\n    return {\n        updatedBoard,\n        updatedMoveHistory,\n        gameOver,\n        winner,\n    };\n}\n\nexport default CombatLogic;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}