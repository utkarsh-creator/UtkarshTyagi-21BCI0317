{"ast":null,"code":"function CombatLogic(gameState, move) {\n  const {\n    selectedCharacter,\n    moveDirection\n  } = move;\n  const {\n    board,\n    currentPlayer\n  } = gameState;\n  const updatedBoard = board.map(row => row.slice());\n  const updatedMoveHistory = [...gameState.moveHistory, `${selectedCharacter}: ${moveDirection}`];\n  let currentPos = null;\n  for (let row = 0; row < 5; row++) {\n    for (let col = 0; col < 5; col++) {\n      if (updatedBoard[row][col] === selectedCharacter) {\n        currentPos = {\n          row,\n          col\n        };\n        break;\n      }\n    }\n    if (currentPos) break;\n  }\n  if (!currentPos) {\n    console.error(\"Character not found on the board.\");\n    return {\n      ...gameState\n    };\n  }\n  const {\n    row,\n    col\n  } = currentPos;\n  let newRow = row,\n    newCol = col;\n  switch (moveDirection) {\n    case 'UP':\n      newRow = row - 1;\n      break;\n    case 'DOWN':\n      newRow = row + 1;\n      break;\n    case 'LEFT':\n      newCol = col - 1;\n      break;\n    case 'RIGHT':\n      newCol = col + 1;\n      break;\n    default:\n      console.error(\"Invalid move direction.\");\n      return {\n        ...gameState\n      };\n  }\n  if (newRow < 0 || newRow >= 5 || newCol < 0 || newCol >= 5) {\n    console.error(\"Move out of bounds.\");\n    return {\n      ...gameState\n    };\n  }\n  const opponentPrefix = currentPlayer === 'A' ? 'B-' : 'A-';\n  const isHero = selectedCharacter.endsWith('H1') || selectedCharacter.endsWith('H2');\n  let opponentEliminated = false;\n  if (isHero) {\n    if (moveDirection === 'UP' || moveDirection === 'DOWN') {\n      for (let i = Math.min(row, newRow); i <= Math.max(row, newRow); i++) {\n        if (updatedBoard[i][col] && updatedBoard[i][col].startsWith(opponentPrefix)) {\n          updatedBoard[i][col] = null;\n          opponentEliminated = true;\n        }\n      }\n    } else if (moveDirection === 'LEFT' || moveDirection === 'RIGHT') {\n      for (let i = Math.min(col, newCol); i <= Math.max(col, newCol); i++) {\n        if (updatedBoard[row][i] && updatedBoard[row][i].startsWith(opponentPrefix)) {\n          updatedBoard[row][i] = null;\n          opponentEliminated = true;\n        }\n      }\n    }\n  } else {\n    if (updatedBoard[newRow][newCol] && updatedBoard[newRow][newCol].startsWith(opponentPrefix)) {\n      updatedBoard[newRow][newCol] = null;\n      opponentEliminated = true;\n    }\n  }\n  updatedBoard[row][col] = null;\n  updatedBoard[newRow][newCol] = selectedCharacter;\n  const gameOver = !updatedBoard.flat().some(cell => cell && cell.startsWith(opponentPrefix));\n  const winner = gameOver ? currentPlayer : null;\n  return {\n    updatedBoard,\n    updatedMoveHistory,\n    gameOver,\n    winner\n  };\n}\n_c = CombatLogic;\nexport default CombatLogic;\nvar _c;\n$RefreshReg$(_c, \"CombatLogic\");","map":{"version":3,"names":["CombatLogic","gameState","move","selectedCharacter","moveDirection","board","currentPlayer","updatedBoard","map","row","slice","updatedMoveHistory","moveHistory","currentPos","col","console","error","newRow","newCol","opponentPrefix","isHero","endsWith","opponentEliminated","i","Math","min","max","startsWith","gameOver","flat","some","cell","winner","_c","$RefreshReg$"],"sources":["C:/Users/Trisha/hitwicket/hitwicket-chess-frontend/src/components/CombatLogic.js"],"sourcesContent":["function CombatLogic(gameState, move) {\n    const { selectedCharacter, moveDirection } = move;\n    const { board, currentPlayer } = gameState;\n\n    const updatedBoard = board.map(row => row.slice());\n    const updatedMoveHistory = [...gameState.moveHistory, `${selectedCharacter}: ${moveDirection}`];\n\n    let currentPos = null;\n    for (let row = 0; row < 5; row++) {\n        for (let col = 0; col < 5; col++) {\n            if (updatedBoard[row][col] === selectedCharacter) {\n                currentPos = { row, col };\n                break;\n            }\n        }\n        if (currentPos) break;\n    }\n\n    if (!currentPos) {\n        console.error(\"Character not found on the board.\");\n        return { ...gameState };\n    }\n\n    const { row, col } = currentPos;\n    let newRow = row, newCol = col;\n\n    switch (moveDirection) {\n        case 'UP':\n            newRow = row - 1;\n            break;\n        case 'DOWN':\n            newRow = row + 1;\n            break;\n        case 'LEFT':\n            newCol = col - 1;\n            break;\n        case 'RIGHT':\n            newCol = col + 1;\n            break;\n        default:\n            console.error(\"Invalid move direction.\");\n            return { ...gameState };\n    }\n\n    if (newRow < 0 || newRow >= 5 || newCol < 0 || newCol >= 5) {\n        console.error(\"Move out of bounds.\");\n        return { ...gameState };\n    }\n\n    const opponentPrefix = currentPlayer === 'A' ? 'B-' : 'A-';\n    const isHero = selectedCharacter.endsWith('H1') || selectedCharacter.endsWith('H2');\n    let opponentEliminated = false;\n\n    if (isHero) {\n        if (moveDirection === 'UP' || moveDirection === 'DOWN') {\n            for (let i = Math.min(row, newRow); i <= Math.max(row, newRow); i++) {\n                if (updatedBoard[i][col] && updatedBoard[i][col].startsWith(opponentPrefix)) {\n                    updatedBoard[i][col] = null;\n                    opponentEliminated = true;\n                }\n            }\n        } else if (moveDirection === 'LEFT' || moveDirection === 'RIGHT') {\n            for (let i = Math.min(col, newCol); i <= Math.max(col, newCol); i++) {\n                if (updatedBoard[row][i] && updatedBoard[row][i].startsWith(opponentPrefix)) {\n                    updatedBoard[row][i] = null;\n                    opponentEliminated = true;\n                }\n            }\n        }\n    } else {\n        if (updatedBoard[newRow][newCol] && updatedBoard[newRow][newCol].startsWith(opponentPrefix)) {\n            updatedBoard[newRow][newCol] = null;\n            opponentEliminated = true;\n        }\n    }\n\n    updatedBoard[row][col] = null;\n    updatedBoard[newRow][newCol] = selectedCharacter;\n\n    const gameOver = !updatedBoard.flat().some(cell => cell && cell.startsWith(opponentPrefix));\n    const winner = gameOver ? currentPlayer : null;\n\n    return {\n        updatedBoard,\n        updatedMoveHistory,\n        gameOver,\n        winner,\n    };\n}\n\nexport default CombatLogic;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}